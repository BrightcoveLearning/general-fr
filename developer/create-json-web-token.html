---
title: 'Création d'un jeton Web JSON (JWT)'
description: 'Dans cette rubrique, vous apprendrez à créer un <span translate="No">Jeton Web JSON</span> (JWT) qui peut être utilisé avec les restrictions de lecture Brightcove.'
parent: Developers
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary> 
  <!-- <br>
  <aside class="bcls-aside bcls-aside--tip">This feature is available for a specific set of customers with access to the Limited Availability phase of Brightcove Playback Restrictions.</aside> -->

  <section class="bcls-section">
    <h2 id="Introduction">Introduction</h2>

    <p>Pour ajouter un niveau de protection supplémentaire lors de l'accès à votre vidéothèque, ou pour appliquer des restrictions au niveau utilisateur pour votre contenu, vous pouvez passer un <span translate="No">Jeton Web JSON (JWT)</span> avec votre appel à l'API de lecture Brightcove. Pour créer le jeton, procédez comme suit :</p>
    <ol class="bcls-tasklist">
      <li><a href="#Generate_public_private_key_pair">Générer une paire de clés public-privé</a></li>
      <li>
        <a href="#Register_public_key">Enregistrer la clé publique avec Brightcove</a>
      </li>
      <li>
        <a href="#Create_a_JSON_Web_Token">Créer un <span translate="No">Jeton Web JSON</span></a>
      </li>
      <li>
        <a href="#Test_playback">Tester la lecture</a>
      </li>
    </ol>
  </section>

  <section class="bcls-section">
    <h2 id="Generate_public_private_key_pair">Générer une paire de clés public-privé</h2>

    <p>Vous (l'éditeur) allez générer une paire de clés publique-privée et fournir la clé publique à Brightcove. Vous utiliserez la clé privée pour signer des jetons. La clé privée n'est pas partagée avec Brightcove.</p>

    <p>
      Il existe plusieurs façons de générer la paire de clés public-privé. Voici quelques exemples :
    </p>
    <h3>
      Exemple de script bash :
    </h3>
    <aside class="bcls-aside bcls-aside--information">Notez que le script ci-dessous utilise le <strong>jq</strong> package pour l'analyse de JSON. Si JQ n'est pas installé, consultez les instructions <a href="https://github.com/stedolan/jq/wiki/Installation">d'installation</a>.</aside>
    <p>
      Exemple de script pour générer la paire de clés :
    </p>
    <pre class="line-numbers"><code class="language-bash" translate="No">#!/bin/bash
set -euo pipefail

NAME=${1:-}
test -z "${NAME:-}" &amp;&amp; NAME="brightcove-playback-auth-key-$(date +%s)"
mkdir "$NAME"

PRIVATE_PEM="./$NAME/private.pem"
PUBLIC_PEM="./$NAME/public.pem"
PUBLIC_TXT="./$NAME/public_key.txt"

ssh-keygen -t rsa -b 2048 -m PEM -f "$PRIVATE_PEM" -q -N ""
openssl rsa -in "$PRIVATE_PEM" -pubout -outform PEM -out "$PUBLIC_PEM" 2&gt;/dev/null
openssl rsa -in "$PRIVATE_PEM" -pubout -outform DER | base64 &gt; "$PUBLIC_TXT"

rm "$PRIVATE_PEM".pub

echo "Public key to saved in $PUBLIC_TXT"
</code></pre>
    <p>
      Exécutez le script :
    </p>
    <pre><code class="language-bash" translate="No">$ bash keygen.sh
</code></pre>

    <details id="Example_using_Go">
      <summary>Exemple utilisant <span translate="No">Aller</span></summary>
      <p>
        Exemple utilisant le <span translate="No">Aller</span> langage de programmation pour générer la paire de clés :
      </p>
      <aside class="bcls-aside bcls-aside--tip">Si vous débutez dans <span translate="No">Go</span>, consultez la page d'accueil de <a href="https://golang.org/">The <span translate="No">Go</span> Programming Language</a>.</aside>
      <pre class="line-numbers"><code class="language-bash" translate="No">package main
  
  import (
    "crypto/rand"
    "crypto/rsa"
    "crypto/x509"
    "encoding/base64"
    "encoding/pem"
    "flag"
    "fmt"
    "io/ioutil"
    "os"
    "path"
    "strconv"
    "time"
  )
  
  func main() {
    var out string
  
    flag.StringVar(&amp;out, "output-dir", "", "Output directory to write files into")
    flag.Parse()
  
    if out == "" {
      out = "rsa-key_" + strconv.FormatInt(time.Now().Unix(), 10)
    }
  
    if err := os.MkdirAll(out, os.ModePerm); err != nil {
      panic(err.Error())
    }
  
    priv, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
      panic(err.Error())
    }
  
    privBytes := x509.MarshalPKCS1PrivateKey(priv)
  
    pubBytes, err := x509.MarshalPKIXPublicKey(priv.Public())
    if err != nil {
      panic(err.Error())
    }
  
    privOut, err := os.OpenFile(path.Join(out, "private.pem"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
      panic(err.Error())
    }
  
    if err := pem.Encode(privOut, &amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: privBytes}); err != nil {
      panic(err.Error())
    }
  
    pubOut, err := os.OpenFile(path.Join(out, "public.pem"), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
    if err != nil {
      panic(err.Error())
    }
  
    if err := pem.Encode(pubOut, &amp;pem.Block{Type: "PUBLIC KEY", Bytes: pubBytes}); err != nil {
      panic(err.Error())
    }
  
    var pubEnc = base64.StdEncoding.EncodeToString(pubBytes)
  
    var pubEncOut = path.Join(out, "public_key.txt")
    if err := ioutil.WriteFile(pubEncOut, []byte(pubEnc+"\n"), 0600); err != nil {
      panic(err.Error())
    }
  
    fmt.Println("Public key saved in " + pubEncOut)
  }
  </code></pre>
    </details>
    <br>

    <details id="Example_using_node_js">
      <summary>Exemple d'utilisation de node.js</summary>
      <p>
        Exemple d'utilisation de node.js pour générer la paire de clés :
      </p>
      <aside class="bcls-aside bcls-aside--tip">Cet exemple de script nécessite la version 11 ou ultérieure du nœud.</aside>
      <pre class="line-numbers"><code class="language-javascript" translate="No">var crypto = require("crypto");
  var fs = require("fs");
  
  var now = Math.floor(new Date() / 1000);
  var dir = "rsa-key_" + now;
  fs.mkdirSync(dir);
  
  crypto.generateKeyPair(
    "rsa",
    {modulusLength: 2048},
    (err, publicKey, privateKey) =&gt; {
      fs.writeFile(
        dir + "/public.pem",
        publicKey.export({ type: "spki", format: "pem" }),
        err =&gt; {}
      );
      fs.writeFile(
        dir + "/public_key.txt",
        publicKey.export({ type: "spki", format: "der" }).toString("base64") +
          "\n",
        err =&gt; {}
      );
      fs.writeFile(
        dir + "/private.pem",
        privateKey.export({ type: "pkcs1", format: "pem" }),
        err =&gt; {}
      );
    }
  );
  
  console.log("Public key saved in " + dir + "/public_key.txt");</code></pre>
    </details>
  </section>

  <section class="bcls-section">
    <h2 id="Register_public_key">Enregistrer la clé publique</h2>
    <p>Vous possédez la clé privée et vous l'utiliserez pour générer des jetons signés. Vous partagerez la clé publique avec Brightcove pour vérifier vos jetons. L'API de clé vous permet d'enregistrer votre clé publique auprès de Brightcove.</p>

    <p>Pour plus de détails sur l'API, consultez le <a href="https://apis.support.brightcove.com/playback-restrictions/guides/authentication-apis.html">Utilisation des API d'authentification</a> document.</p>
  </section>

  <section class="bcls-section">
    <h2 id="Create_a_JSON_Web_Token">Créer un <span translate="No">Jeton Web JSON</span></h2>

    <p>Les éditeurs créent un <a href="https://jwt.io/introduction/" translate="No">jeton Web JSON</a> (JWT). Le jeton est signé avec l'algorithme RSA à l'aide de l'algorithme de hachage SHA-256 (identifié dans la spécification JWT comme "<a href="https://ldapwiki.com/wiki/RS256">RS256</a>") Aucun autre algorithme JWT ne sera pris en charge.</p>
    <p>
      Un sous-ensemble des <a href="https://auth0.com/docs/tokens/jwt-claims" translate="No">revendications standard JSON Web Token</a> sera utilisé, ainsi que certaines revendications privées définies par Brightcove. Vous allez créer un <span translate="No">Jeton Web JSON</span> signé avec votre clé privée.
    </p>
  </section>

    <section class="bcls-section">
      <h2 id="Claims_for_Static_URL_Delivery">Réclamations pour la livraison d'URL statique</h2>
      <p>
        Les revendications suivantes peuvent être utilisées avec la livraison d'URL statique de Brightcove.
      </p>
      <aside class="bcls-aside bcls-aside--tip">Notez qu'aucune des revendications n'est requise pour la livraison d'URL statique.</aside>

      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <th>Champ</th>
            <th>Type</th>
            <th>Obligatoire</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td><code translate="No">accid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>ID de compte propriétaire du contenu en cours de lecture</td>
          </tr>
          <tr>
            <td><code translate="No">drules</code></td>
            <td>Chaîne []</td>
            <td></td>
            <td>Liste des ID d'action de règle de remise à appliquer, reportez-vous à la section <a href="https://apis.support.brightcove.com/delivery-rules/getting-started/implementing-delivery-rules.html">Implémentation des règles de remise</a> pour plus Si le paramètre de requête config_id est également défini, il sera ignoré, car cette revendication le remplace.</td>
          </tr>
          <tr>
            <td><code translate="No">exp</code></td>
            <td>Entier</td>
            <td></td>
            <td>Heure que ce jeton ne sera plus valide, en secondes depuis l'époque. Ne doit pas être plus de 30 jours à partir de <code translate="No">iat</code></td>
          </tr>
          <tr>
            <td><code translate="No">iat</code></td>
            <td>Entier</td>
            <td></td>
            <td>Heure d'émission de ce jeton, en secondes depuis l'époque</td>
          </tr>
          <tr>
            <td><code translate="No">conid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>S'il est présent, ce jeton autorisera uniquement la récupération de licence pour un ID vidéo Video Cloud spécifique.
              <br><br>
              Doit être un identifiant vidéo valide. Notez que l'ID de référence n'est pas pris en charge.
            </td>
          </tr>
          <tr>
            <td><code translate="No">pro</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>Spécifie un type de protection dans le cas où plusieurs sont disponibles pour une seule vidéo.
              <br><br>
              Valeurs :
              <ul>
                <li>
                  « » (par défaut pour un contenu clair)
                </li>
                <li>
                  « aes128"
                </li>
                <li>
                  « veuve »
                </li>
                <li>
                  « prêt à jouer »
                </li>
                <li>
                  « fairplay »
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td><code translate="No">vod</code></td>
            <td>Objet</td>
            <td></td>
            <td>Contient des options de configuration spécifiques pour la vidéo à la demande.</td>
          </tr>
          <tr>
            <td><code translate="No">vod.ssai</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>Votre ID de configuration d'insertion d'annonces côté serveur (SSAI). Cette revendication est <strong>requise</strong> pour récupérer un HLS ou un DASH VMAP.</td>
          </tr>
        </tbody>
      </table>
      <br>
      <p>
        Voici un exemple de <span translate="No">Jeton Web JSON</span> (JWT) affirme que vous pourriez utiliser :
      </p>
      <pre class="line-numbers"><code class="language-json" translate="No">{
// account id: JWT is only valid for this accounts
"accid":"4590388311111",
// drules: list of delivery rule IDs to be applied
"drules": ["0758da1f-e913-4f30-a587-181db8b1e4eb"]
// expires: timestamp when JWT expires
"exp":1577989732,
// issued at: timestamp when the JWT was created
"iat":1575484132,
// content id: JWT is only valid for video ID
"conid":"5805807122222",
// protection: specify a protection type in the case where multiple are available for a single video
"pro":"aes128",
// VOD specific configuration options
"vod":{
// SSAI configuration to apply
"ssai":"efcc566-b44b-5a77-a0e2-d33333333333"
}
}</code></pre>
    </section>

    <section class="bcls-section">
      <h2 id="Claims_for_Playback_Restrictions">Réclamations pour restrictions de lecture</h2>
      <p>
        Les revendications suivantes peuvent être utilisées avec <a href="https://apis.support.brightcove.com/playback-restrictions/getting-started/overview-playback-restrictions.html">Restrictions de lecture Brightcove</a>.
      </p>
      <aside class="bcls-aside bcls-aside--information">Lorsque vous utilisez les droits de lecture avec DRM, vous ne pouvez pas utiliser AES-128.</aside> <aside class="bcls-aside bcls-aside--information">Les champs obligatoires généraux sont obligatoires pour toutes les fonctionnalités.</aside> 

      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <th style="border-bottom:1px solid #707070;">Fonctionnalité</th>
            <th style="border-bottom:1px solid #707070;">Champ</th>
            <th style="border-bottom:1px solid #707070;">Type</th>
            <th style="border-bottom:1px solid #707070;">Requis pour la fonctionnalité</th>
            <th style="border-bottom:1px solid #707070;">DRM uniquement</th>
            <th style="border-bottom:1px solid #707070;">Description</th>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td rowspan="5" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Généralités</td>
            <td><code translate="No">accid</code></td>
            <td>Chaîne</td>
            <td>Oui</td>
            <td></td>
            <td>ID de compte propriétaire du contenu en cours de lecture</td>
          </tr>
          <tr>
            <td><code translate="No">exp</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td></td>
            <td>Heure que ce jeton ne sera plus valide, en secondes depuis l'époque. Ne doit pas être plus de 30 jours à partir de <code translate="No">iat</code></td>
          </tr>
          <tr>
            <td><code translate="No">iat</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td></td>
            <td>Heure d'émission de ce jeton, en secondes depuis l'époque</td>
          </tr>
          <tr>
            <td><code translate="No">ua</code></td>
            <td>Chaîne</td>
            <td></td>
            <td></td>
            <td>S'il est présent, ce jeton ne sera valide que pour les demandes de cet User-Agent.
              <br><br>
              Ce champ n'a pas à suivre de format particulier.
              <br>
              Vous devez avoir <strong>Protection des clés de licence</strong> activée.
            </td>
          </tr>
          <tr>
            <td><code translate="No">conid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td></td>
            <td>S'il est présent, ce jeton autorise uniquement la récupération de licence pour un identifiant vidéo Video Cloud spécifique.
              <br><br>
              Doit être un identifiant vidéo valide
              <br>
              Vous devez avoir <strong>Protection des clés de licence</strong> activée.
            </td>
          </tr>
          <tr>
            <td rowspan="5" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Droits de lecture</td>
            <td><code translate="No">pkid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td></td>
            <td>ID de clé publique utilisé pour vérifier ce jeton.
              <br><br>
              La clé publique enregistrée auprès du service d'autorisation de lecture de Brightcove doit utiliser le format de clé RSA. Les clés EC créées précédemment ne fonctionneront pas.
              <br><br>
              Ce champ n'est pas obligatoire et non validé
            </td>
          </tr>
           <tr>
            <td><code translate="No">nbf</code></td>
            <td>Entier</td>
            <td></td>
            <td></td>
            <td>Heure que ce jeton commence à être valide, en secondes depuis l'époque</td>
          </tr>
          <tr>
            <td><code translate="No">prid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td></td>
            <td> <code translate="No">playback_rights_id</code>A. Utilisé pour remplacer l'identifiant défini dans le catalogue pour cette vidéo
              <br><br>
              Ce champ n'est pas validé
            </td>
          </tr>
           <tr>
            <td><code translate="No">tags</code></td>
            <td>&lt;Chaînes de tableau &gt;</td>
            <td></td>
            <td></td>
            <td>s'il est présent, ce jeton n'est valide que pour les vidéos qui ont les valeurs de balises répertoriées. Seules ces vidéos sont autorisées pour la lecture.</td>
          </tr>
          <tr>
            <td><code translate="No">vids</code></td>
            <td>&lt;Chaînes de tableau &gt;</td>
            <td></td>
            <td></td>
            <td>S'il est présent, ce jeton autorisera uniquement la récupération de licence pour un ensemble d'identifiants vidéo.</td>
          </tr>
          <tr>
            <td rowspan="6" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Flux simultanés</td>
            <td><code translate="No">uid</code></td>
            <td>Chaîne</td>
            <td>Oui</td>
            <td>Oui</td>
            <td>ID utilisateur de la visionneuse de fin. Ce champ est utilisé pour mettre en corrélation plusieurs sessions afin d'appliquer la concurrence de flux.
              <br><br>
              <strong>Obligatoire</strong> pour l'enregistrement de l'appareil
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">climit</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td>Oui</td>
            <td>Lorsque ce champ est inclus, il active la vérification de la concurrence Stream ainsi que les demandes de renouvellement de licence. Cette valeur indique le nombre d'observateurs simultanés autorisés.
              <br><br>
              <strong>Obligatoire</strong> pour la simultanéité des sessions
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">cbeh</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>Oui</td>
            <td>Définissez la valeur sur <code translate="No">BLOCK_NEW</code> pour permettre aux limites de flux simultanées de bloquer toute nouvelle demande, même du même utilisateur, lorsque le nombre maximum de flux est atteint.
              <br><br>
              Réglez la valeur sur <code translate="No">BLOCK_NEW_USER</code> de bloquer toute nouvelle demande d'un nouvel utilisateur uniquement lorsque le nombre maximum de flux est atteint.
              <br><br>
              La valeur par défaut bloque le flux le plus ancien lorsque le nombre maximal de flux est atteint.
            </td>
            <!-- <td>DRM only</td> -->
          </tr>   
          <tr>
            <td><code translate="No">cexp</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>Oui</td>
            <td>Expiration simultanée de la session : la durée par défaut est deux fois supérieure à la durée du contenu.
              <br><br>
              Cela définit la durée de validité de la session, après quoi l'utilisateur final doit démarrer une nouvelle session pour continuer la lecture. Exemple : <code translate="No">2h</code> ou <code translate="No">42m</code>
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">sid</code></td>
            <td>Chaîne</td>
            <td></td>
            <td>Oui</td>
            <td>La spécification de l'ID de session du flux actif vous permet de contrôler la manière dont une session est définie. Par défaut, une session est définie comme User-Agent (navigateur) + adresse IP et ID vidéo.
              <br><br>
                Par exemple, vous pouvez assouplir la définition de session en adresse IP + ID vidéo
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">maxu</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td></td>
            <td>
              S'il est présent, ce jeton ne sera valable que pour ce nombre de demandes de licence.
              <br><br>
              <ul>
                <li>
                  Pour HLSE, les joueurs effectuent plusieurs requêtes lors de la lecture d'une vidéo, généralement une par format associé. Le <code translate="No">maxu</code> doit être réglé suffisamment haut pour tenir compte de ces demandes supplémentaires.
                </li>
                <!-- <li>
                  For DRM, one license request is made per playback
                </li> -->
              </ul>
              <strong>Obligatoire</strong> pour le suivi des sessions ; HLSe (AES-128) uniquement
              <br>
              Vous devez avoir <strong>Protection des clés de licence</strong> activée.
            </td>
          </tr>
          <tr>
            <td rowspan="3" style="background-color:#dbdbdb;font-weight: bold;border-bottom:1px solid #707070;">Limites des périphériques</td>
            <td><code translate="No">uid</code></td>
            <td>Chaîne</td>
            <td>Oui</td>
            <td>Oui</td>
            <td>ID utilisateur de la visionneuse de fin. Ce champ est utilisé pour mettre en corrélation plusieurs sessions afin d'appliquer la concurrence de flux.
              <br><br>
              <strong>Obligatoire</strong> pour l'enregistrement de l'appareil
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">dlimit</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td>Oui</td>
            <td>Lorsque ce champ est inclus, il contrôle le nombre de périphériques pouvant être associés à l'utilisateur spécifié (<code translate="No">uid</code>). La valeur doit être &gt; <code translate="No">0</code>.
              <br><br>
              Les appareils précédemment autorisés continueront de fonctionner si le <code translate="No">dlimit</code> la valeur est supprimée dans les demandes ultérieures.
              <br><br>
              Exemple : si la valeur est définie sur <code translate="No">3</code>, l'utilisateur peut jouer sur les appareils A, B et C (tout est autorisé). Essayer de jouer sur l'appareil D serait refusé.
              <br><br>
              Si la valeur est remplacée par <code translate="No">1</code>, l'utilisateur peut toujours lire sur les trois appareils A, B et C, à moins que les appareils ne soient révoqués manuellement en gérant les appareils avec l'API <a href="https://apis.support.brightcove.com/playback-rights/references/devices-api/reference.htmlc/#operation/GetDevices">Playback Rights</a>.
              <br><br>
              <strong>Obligatoire</strong> pour l'enregistrement de l'appareil
            </td>
            <!-- <td>DRM only</td> -->
          </tr>
          <tr>
            <td><code translate="No">maxip</code></td>
            <td>Entier</td>
            <td>Oui</td>
            <td></td>
            <td>S'il est présent, ce token ne pourra être utilisé que par ce nombre d'adresses IP différentes. 
              <br><br>
              <strong>Obligatoire</strong> pour le suivi des sessions ; HLSe (AES-128) uniquement
              <br>
              Vous devez avoir <strong>Protection des clés de licence</strong> activée.
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section class="bcls-section">
      <h2 id="Generate_a_token">Générer un jeton</h2>
      <p>
        Les bibliothèques sont couramment disponibles pour générer des jetons JWT. Pour plus de détails, consultez le <a href="https://jwt.io/" translate="No">Jetons Web JSON</a> placer.
      </p>
      <h4>
        Exemple de script bash :
      </h4>
      <p>
        Exemple de script pour générer le jeton JWT :
      </p>
      <pre class="line-numbers"><code class="language-bash" translate="No">#! /usr/bin/env bash
# Static header fields.
HEADER='{
	"type": "JWT",
	"alg": "RS256"
}'

payload='{
	"accid": "{your_account_id}"
}'

# Use jq to set the dynamic `iat` and `exp`
# fields on the payload using the current time.
# `iat` is set to now, and `exp` is now + 1 second.
PAYLOAD=$(
	echo "${payload}" | jq --arg time_str "$(date +%s)" \
	'
	($time_str | tonumber) as $time_num
	| .iat=$time_num
	| .exp=($time_num + 60 * 60)
	'
)

function b64enc() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

function rs_sign() { openssl dgst -binary -sha256 -sign playback-auth-keys/private.pem ; }

JWT_HDR_B64="$(echo -n "$HEADER" | b64enc)"
JWT_PAY_B64="$(echo -n "$PAYLOAD" | b64enc)"
UNSIGNED_JWT="$JWT_HDR_B64.$JWT_PAY_B64"
SIGNATURE=$(echo -n "$UNSIGNED_JWT" | rs_sign | b64enc)

echo "$UNSIGNED_JWT.$SIGNATURE"
</code></pre>
      <p>
        Exécutez le script :
      </p>
      <pre><code class="language-bash" translate="No">$ bash jwtgen.sh
</code></pre>
      <br>

      <details>
        <summary>
          Exemple utilisant <span translate="No">Aller</span>
        </summary>
        <p>Voici un exemple de référence <span translate="No">Aller</span> implémentation (en tant qu'outil cli) pour générer des jetons sans utiliser de bibliothèque tierce :</p>
        <pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

// Header is the base64UrlEncoded string of a JWT header for the RS256 algorithm
const RSAHeader = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9"

// Header is the base64UrlEncoded string of a JWT header for the EC256 algorithm
const ECHeader = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9"

// Claims represents constraints that should be applied to the use of the token
type Claims struct {
	Iat   float64 `json:"iat,omitempty"`   // Issued At
	Exp   float64 `json:"exp,omitempty"`   // Expires At
	Accid string  `json:"accid,omitempty"` // Account ID
	Conid string  `json:"conid,omitempty"` // Content ID
	Maxu  float64 `json:"maxu,omitempty"`  // Max Uses
	Maxip float64 `json:"maxip,omitempty"` // Max IPs
	Ua    string  `json:"ua,omitempty"`    // User Agent
}

func main() {
	var key, algorithm string

	c := Claims{Iat: float64(time.Now().Unix())}

	flag.StringVar(&amp;key, "key", "", "Path to private.pem key file")
	flag.StringVar(&amp;c.Accid, "account-id", "", "Account ID")
	flag.StringVar(&amp;c.Conid, "content-id", "", "Content ID (eg, video_id or live_job_id)")
	flag.Float64Var(&amp;c.Exp, "expires-at", float64(time.Now().AddDate(0, 0, 1).Unix()), "Epoch timestamp (in seconds) for when the token should stop working")
	flag.Float64Var(&amp;c.Maxu, "max-uses", 0, "Maximum number of times the token is valid for")
	flag.Float64Var(&amp;c.Maxip, "max-ips", 0, "Maximum number of unique IP addresses the token is valid for")
	flag.StringVar(&amp;c.Ua, "user-agent", "", "User Agent that the token is valid for")
	flag.StringVar(&amp;algorithm, "algo", "", "Key algorithm to use for signing. Valid: ec256, rsa256")
	flag.Parse()

	if key == "" {
		fmt.Printf("missing required flag: -key\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if algorithm == "" {
		fmt.Printf("missing required flag: -algo\n\n")
		flag.Usage()
		os.Exit(2)
	}

	if algorithm != "rsa256" &amp;&amp; algorithm != "ec256" {
		fmt.Printf("missing valid value for -algo flag. Valid: rsa256, ec256\n\n")
		flag.Usage()
		os.Exit(3)
	}

	if c.Accid == "" {
		fmt.Printf("missing required flag: -account-id\n\n")
		flag.Usage()
		os.Exit(4)
	}

	bs, err := json.Marshal(c)
	if err != nil {
		fmt.Println("failed to marshal token to json", err)
		os.Exit(5)
	}

	kbs, err := ioutil.ReadFile(key)
	if err != nil {
		fmt.Println("failed to read private key", err)
		os.Exit(6)
	}

	if algorithm == "rsa256" {
		processRSA256(kbs, bs)
	} else {
		processEC256(kbs, bs)
	}
}

func processRSA256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(7)
	}

	if block.Type != "RSA PRIVATE KEY" {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(8)
	}

	pKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		fmt.Println("failed to parse rsa private key", err)
		os.Exit(9)
	}

	message := RSAHeader + "." + base64.RawURLEncoding.EncodeToString(bs)

	hash := crypto.SHA256
	hasher := hash.New()
	_, _ = hasher.Write([]byte(message))
	hashed := hasher.Sum(nil)

	r, err := rsa.SignPKCS1v15(rand.Reader, pKey, hash, hashed)
	if err != nil {
		fmt.Println("failed to sign token", err)
		os.Exit(10)
	}

	sig := strings.TrimRight(base64.RawURLEncoding.EncodeToString(r), "=")

	fmt.Println(message + "." + sig)
}

func processEC256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(7)
	}

	if block.Type != "EC PRIVATE KEY" {
		fmt.Println("failed to decode PEM block containing private key")
		os.Exit(8)
	}

	pkey, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		fmt.Println("failed to parse ec private key", err)
		os.Exit(9)
	}

	message := ECHeader + "." + base64.RawURLEncoding.EncodeToString(bs)
	hash := sha256.Sum256([]byte(message))

	r, s, err := ecdsa.Sign(rand.Reader, pkey, hash[:])
	if err != nil {
		fmt.Println("failed to sign token", err)
		os.Exit(10)
	}

	curveBits := pkey.Curve.Params().BitSize

	keyBytes := curveBits / 8
	if curveBits%8 &gt; 0 {
		keyBytes++
	}

	rBytes := r.Bytes()
	rBytesPadded := make([]byte, keyBytes)
	copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)

	sBytes := s.Bytes()
	sBytesPadded := make([]byte, keyBytes)
	copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)

	out := append(rBytesPadded, sBytesPadded...)

	sig := base64.RawURLEncoding.EncodeToString(out)
	fmt.Println(message + "." + sig)
}
</code></pre>
</details>

      <h4>Résultats</h4>
      <p>
        Voici un exemple de jeton décodé utilisant <a href="https://jwt.io/">https://JWT.io</a> spécifiant l'ensemble complet des revendications :
      </p>
      <p>
        EN-TÊTE :
      </p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  "alg": "RS256",
  "type": "JWT"
}
</code></pre>

      <p>
        CHARGE UTILE :
      </p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  "accid": "1100863500123",
  "conid": "51141412620123",
  "exp": 1554200832,
  "iat": 1554199032,
  "maxip": 10,
  "maxu": 10,
  "ua": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"
}
</code></pre>
    </section>

    <section class="bcls-section">
      <h2 id="Test_playback">Tester la lecture</h2>

      <p>Bien que ce n'est pas obligatoire, vous pouvez tester la lecture vidéo avant de configurer un lecteur.</p>
      <p>
        Demande de lecture :
      </p>
      <pre class="line-numbers"><code class="language-http" translate="No">curl -X GET \
 -H 'Authorization: Bearer {JWT}' \
 https://edge-auth.api.brightcove.com/playback/v1/accounts/{your_account_id}/videos/{your_video_id}
</code></pre>
</section>
</article>